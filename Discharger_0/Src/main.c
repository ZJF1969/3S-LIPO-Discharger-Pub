/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#include "ADC.h"
#include "IRQ.h"
#include "stm32f303re_sys_init.h"


#define GetPeriod(x) (1 / (float)x)


const uint32_t SYS_clk = 72000000;


/***************************************************************************************************************************************/

/*	Process_Vars obj and handle	*/

Process_Vars_Obj_Alias Process_Vars;			// Define struct obj of type Process_Vars_Obj_Alias
Process_Vars_Obj_Alias *Process_Vars_Handle;	// Define struct obj pointer to type Process_Vars_Obj_Alias

/***************************************************************************************************************************************/

/*	State Machine function prototypes  */

// Alpha states
void A0(void);  //state A0
void A1(void);  //state A1
void A2(void);  //state A2
void A3(void);

// Beta states
void B0(void);
void B1(void);
void B2(void);

/***************************************************************************************************************************************/

/*	State machine function pointers */

void (*State_ptr)(void);       // State machine pointer

/***************************************************************************************************************************************/


int PC13_cnt = 0;		// Debounce vars
int PC13_lock = 0;
BOOL PC13_pressed = FALSE;

int state = 0;			// Error catch

/***************************************************************************************************************************************/

int main(void){

	SysInit();
	GPIOConfig();
	TIMConfig();
	state = ADC_INIT();		// Init and cal ADC1, setup var obj
	DMA1_init();
	OPAMP_init();


	state = Process_Vars_Obj_init(&Process_Vars, Process_Vars);	// Init the Process_Vars obj
	if (state == 1) {}

	DMA_CH1_config();

	State_ptr = &B0;	// Set state machine entry to Idle state


	/*	Setup ADC1	*/

	state = ADC1_IRQ_Config();				// Setup ADC1 IRQs
	if (state == 1) { A2(); }

	state = EnableADC1();					// EN ADC1
	if (state == 1) { A2(); }

	state = GetVDDA();						// Sample the current VDDA (upper ref)
	if (state == 1) { A2(); }

	state = ADC1_Param_Setup();
	if (state == 1) { A2(); }



	while(1) {


		// WATCHDOG


		/*	Check for ON/OFF btn activity	*/

		PC13_pressed = Debounce( (((GPIOC->IDR) & GPIO_IDR_13) >> 13), &PC13_cnt, &PC13_lock); //poll blue btn, PC13, active low, service Debounce

		if (PC13_pressed == TRUE && Process_Vars_Handle->SYS_ON == FALSE){

			if(BattCheck() == TRUE){

				Process_Vars_Handle->SYS_ON = TRUE;
				State_ptr = &A0;

			}

		}
		else if(PC13_pressed == TRUE && Process_Vars_Handle->SYS_ON == TRUE){

			Process_Vars_Handle->SYS_ON = FALSE;
			State_ptr = &B0;

			// Shut down state

			// TURN OFF LED

		}


		/*	Enter state machine	*/

		(*State_ptr)();

	}

}

/***************************************************************************************************************************************/

/* Startup state */

void A0(void){

	// Turn on LED

	ADC1_IRQ_EN();							// EN ADC1 IRQs

	ADC1_HANDLE->ADC1_IDLE = TRUE;
	ADC1_HANDLE->ADC1_DATA_GOOD = TRUE;

	state = ADC1_Cycle_Start();		// Get cell voltages
	if (state == 1) { A2(); }

	State_ptr = &A1;


}

/***************************************************************************************************************************************/

/*	Capture state  */

void A1(void){

	uint8_t result = 0;

	if (Process_Vars_Handle->ADC_CAPTURES_RUNNING == TRUE &&
			ADC1_HANDLE->ADC1_IDLE == TRUE &&
			ADC1_HANDLE->ADC1_DATA_GOOD == TRUE){				// If ADC1 burst running and ADC1 conv done and

		ADC1_HANDLE->ADC1_IDLE = FALSE;												// Ready to start a conv

		switch (ADC1_HANDLE->ADC1_CURRENT_CAPTURE) {

			case 1:

				result = ADC1_Start_Conv(1, &ADC1_HANDLE->ADC1_CH1_DATA[0]);		// Start ADC1 CH1 conv, VC1
				if(result == 1){ /*set error*/ }

				break;


			case 2:

				result = ADC1_Start_Conv(2, &ADC1_HANDLE->ADC1_CH2_DATA[0]);		// Start ADC1 CH2 conv, VC2
				if(result == 1){ /*set error*/ }

				break;


			case 3:

				result = ADC1_Start_Conv(3, &ADC1_HANDLE->ADC1_CH4_DATA[0]);		// Start ADC1 CH3 conv, VC3
				if(result == 1){ /*set error*/ }

				break;


			case 4:

				/*
				result = ADC1_Start_Conv(4, &ADC1_HANDLE->ADC1_CH4_DATA[0]);		// Start ADC1 CH4 conv, NTC
				if(result == 1){ /*set error }
				*/

				ADC1_HANDLE->ADC1_IDLE = TRUE;										// Reverse to IDLE
				Process_Vars_Handle->ADC_CAPTURES_RUNNING = FALSE;					// ADC captures done, TODO move this to case 5 and add in ADC CH4
				State_ptr = &A1;

				state = ADC1_Cycle_Start();
				if (state == 1) { A2(); }

				break;


			default:

				/* Error Catch */

				ADC1_HANDLE->ADC1_DATA_GOOD = FALSE;
				Process_Vars_Handle->ADC_CAPTURES_RUNNING = FALSE;
				ADC1_HANDLE->ADC1_IDLE = TRUE;

				break;


		}

	}

}

/***************************************************************************************************************************************/

/*	Burst finished, process data, move to reset state	*/

void A2(void){

	//ADC1_Process_Data();

	State_ptr = &B2;

}

/***************************************************************************************************************************************/


/*	Error state  */

uint32_t diag_A2 = 0;

void A3(void){

	while(1);	// Get stuck for diag

}

/***************************************************************************************************************************************/

/*	Idle state  */
/*	Do nothing	*/

void B0(void){


}

/***************************************************************************************************************************************/

/*	Process Data State  */

void B1(void){



}

/***************************************************************************************************************************************/

float new_d = 30;

void B2(void){

	new_d = (ADC1_HANDLE->ADC1_AIN * 0.25) + 0.175;

	//UpdatePWM(new_d);

	State_ptr = &A1;


}

/***************************************************************************************************************************************/

/*	Function to init the Process_Vars struct obj, assign handle the obj address if successful	*/

uint8_t Process_Vars_Obj_init(void *pMemory, Process_Vars_Obj_Alias obj){

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)calloc(1, sizeof(obj));

	if (Process_Vars_Handle == NULL) { return 1; }

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)pMemory;

    return 0;

}

/***************************************************************************************************************************************/

/* Setup for one-shot */
/* Debounce is 200 counts max, high if > 100, low if < 100 */
/* Input is active low */

BOOL Debounce(uint8_t input, int *cnt, int *btn_lock){

	if (input == 0 && *cnt < 200) { (*cnt)++; } 		// increment counter
	else if (input == 1 && *cnt > 0) { (*cnt)--; }    	// decrement counter

	if (*btn_lock == 0){

		if (*cnt > 100) {

			*btn_lock = 1;			// lock btn until released
			return TRUE;				// send one-shot
		}
	}
	else if (*btn_lock == 1) {

		if (*cnt <= 100) {

			*btn_lock = 0;			// release lock
		}
	}

	return FALSE;
}

/***************************************************************************************************************************************/

void Millisec(float microSec){

	TIM3 -> ARR = (microSec / 1000000) / GetPeriod(SYS_clk); //load TIM3 counter
	TIM3 -> CR1 |= 1; //start timer

	while(!ms_done_flag);

}










