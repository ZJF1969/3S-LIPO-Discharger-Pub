/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#include "ADC.h"
#include "IRQ.h"
#include "stm32f303re_sys_init.h"


#define GetPeriod(x) (1 / (float)x)

#define ever ;;


const uint32_t SYS_CLK = 72000000;

const float COARSE_SETPOINT = 3.8;
const float FINE_SETPOINT = 3.75;


/***************************************************************************************************************************************/

/*	Process_Vars obj and handle	*/

Process_Vars_Obj_Alias Process_Vars;			// Define struct obj of type Process_Vars_Obj_Alias
Process_Vars_Obj_Alias *PROCESS_VARS_HANDLE;	// Define struct obj pointer to type Process_Vars_Obj_Alias

/***************************************************************************************************************************************/

int PC13_cnt = 0;		// Debounce vars
int PC13_lock = 0;
BOOL PC13_pressed = FALSE;

int state = 0;			// Error catch

/***************************************************************************************************************************************/

/* Main func declares */

void button_check(void);
void startup_checks(void);
void service_system(void);
void discharge_logic(void);
void shutdown(void);
void get_ADC_capture(void);
void process_ADC_data(void);
//void error_catch(void); 		// Externed in header

/***************************************************************************************************************************************/

int main(void){

	SysInit();
	GPIOConfig();
	TIMConfig();
	state = ADC_INIT();		// Init and cal ADC1, setup var obj
	DMA1_init();
	OPAMP_init();


	state = Process_Vars_Obj_init(&Process_Vars, Process_Vars);	// Init the Process_Vars obj
	if (state == 1) {}

	DMA_CH1_config();

	/*	Setup ADC1	*/

	state = ADC1_IRQ_Config();				// Setup ADC1 IRQs
	if (state == 1) { error_catch(); }

	state = EnableADC1();					// EN ADC1
	if (state == 1) { error_catch(); }

	state = GetVDDA();						// Sample the current VDDA (upper ref)
	if (state == 1) { error_catch(); }

	state = ADC1_Param_Setup();
	if (state == 1) { error_catch(); }



	for(ever){

		// WATCHDOG

		button_check();		// Check for ON/OFF btn activity

		service_system();	// Perform the discharger logic



	}

}



/***************************************************************************************************************************************/

/* Check for ON/OFF button and set vars */

void button_check(void){

	PC13_pressed = Debounce( (((GPIOC->IDR) & GPIO_IDR_13) >> 13), &PC13_cnt, &PC13_lock); //poll blue btn, PC13, active low, service Debounce

	if (PC13_pressed == TRUE && PROCESS_VARS_HANDLE->PROCESS_RUNNING == FALSE){

		if(BattCheck() == TRUE){

			startup_checks();
			PROCESS_VARS_HANDLE->PROCESS_RUNNING = TRUE;

		}
		else{

			// Hold ERROR LED on for a while

		}

	}
	else if(PC13_pressed == TRUE && PROCESS_VARS_HANDLE->PROCESS_RUNNING == TRUE){

		PROCESS_VARS_HANDLE->PROCESS_RUNNING = FALSE;
		// Shut down func

		// TURN OFF LED

	}
}

/***************************************************************************************************************************************/

/* Startup duties */

void startup_checks(void){

	ADC1_IRQ_EN();							// EN ADC1 IRQs

	ADC1_HANDLE->ADC1_IDLE = TRUE;
	ADC1_HANDLE->ADC1_DATA_GOOD = TRUE;
	ADC1_HANDLE->ADC1_CURRENT_CAPTURE = 1;						// Reset to first ADC1 CH

	PROCESS_VARS_HANDLE->ADC_CAPTURES_RUNNING = TRUE;			// Start ADC1 burst

	get_ADC_capture();		// Get Vcells
	process_ADC_data();		// Process vals

	if (PROCESS_VARS_HANDLE->V_C1 > 3.75 || PROCESS_VARS_HANDLE->V_C2 > 3.75 || PROCESS_VARS_HANDLE->V_C3 > 3.75){		// Check if discharge is applicable.

		if (PROCESS_VARS_HANDLE->V_C1 < 3.6 || PROCESS_VARS_HANDLE->V_C2 < 3.6 || PROCESS_VARS_HANDLE->V_C3 < 3.6){		// Check for out of range / damaged cells

			//State_ptr = ERROR STATE

		}

		if (PROCESS_VARS_HANDLE->V_C1 < 3.8 || PROCESS_VARS_HANDLE->V_C2 < 3.8 || PROCESS_VARS_HANDLE->V_C3 < 3.8){

			PROCESS_VARS_HANDLE->Current_Setpoint = FINE_SETPOINT;		// Set to fine setpoint if close to done

		}
		else{

			PROCESS_VARS_HANDLE->Current_Setpoint = COARSE_SETPOINT;	// Otherwise use coarse setpoint

		}


		start_cell_check_timer();

		// Turn on LED
		// Start main logic

	}
	else{

		//State_ptr = DONE STATE // No discharge needed

	}
}

/***************************************************************************************************************************************/

/* Main service duties for discharge, run every cycle */

void service_system(void){

	if (PROCESS_VARS_HANDLE->PROCESS_RUNNING == TRUE){

		if (PROCESS_VARS_HANDLE->DISCHARGE_ON == FALSE){

			PROCESS_VARS_HANDLE->DISCHARGE_ON = TRUE;
			// START DISCHARGE

		}

		if (PROCESS_VARS_HANDLE->ADC_CAPTURES_RUNNING == TRUE){		// If time to get ADC captures

			get_ADC_capture();										// Enter capture routine to get next input

		}

		discharge_logic();


	}
}

/***************************************************************************************************************************************/

/* Main logic for discharge ON/OFF */

void discharge_logic(void){






}

/***************************************************************************************************************************************/

/* Shutdown duties */

void shutdown(void){



}


/***************************************************************************************************************************************/

/* ADC capture */

void get_ADC_capture(void){

	uint8_t result = 0;

	if (ADC1_HANDLE->ADC1_IDLE == TRUE &&
		ADC1_HANDLE->ADC1_DATA_GOOD == TRUE){				// If ADC is idle and data ok so far

		ADC1_HANDLE->ADC1_IDLE = FALSE;						// Ready to start a conv

		switch (ADC1_HANDLE->ADC1_CURRENT_CAPTURE) {

			case CH0:

				result = ADC1_Start_Conv(CH0, &ADC1_HANDLE->ADC_CH0_DATA[0]);		// Start ADC CH0 conv, VC1
				if(result == 1){ error_catch(); }

				ADC1_HANDLE->ADC1_CURRENT_CAPTURE++;

				break;


			case CH1:

				result = ADC1_Start_Conv(CH1, &ADC1_HANDLE->ADC_CH1_DATA[0]);		// Start ADC CH1 conv, VC2
				if(result == 1){ error_catch(); }

				ADC1_HANDLE->ADC1_CURRENT_CAPTURE++;

				break;


			case CH2:

				result = ADC1_Start_Conv(CH2, &ADC1_HANDLE->ADC_CH2_DATA[0]);		// Start ADC CH2 conv, VC3
				if(result == 1){ error_catch(); }

				ADC1_HANDLE->ADC1_CURRENT_CAPTURE++;

				break;


			case CH3:


				result = ADC1_Start_Conv(CH3, &ADC1_HANDLE->ADC_CH3_DATA[0]);		// Start ADC CH3 conv, Batt Current
				if(result == 1){ error_catch(); }

				ADC1_HANDLE->ADC1_CURRENT_CAPTURE++;

				break;


			case CH4:

				result = ADC1_Start_Conv(CH4, &ADC1_HANDLE->ADC_CH4_DATA[0]);		// Start ADC CH4 conv, NTC
				if(result == 1){ error_catch(); }

				ADC1_HANDLE->ADC1_CURRENT_CAPTURE++;

				break;


			case 5:																	// Final case for wrap up duties

				ADC1_HANDLE->ADC1_IDLE = TRUE;										// Reset to IDLE
				PROCESS_VARS_HANDLE->ADC_CAPTURES_RUNNING = FALSE;					// ADC captures done, shut off capture routine

				process_ADC_data();													// Process raw ADC data into voltage / amps / temp


			default:

				/* Error Catch */

				ADC1_HANDLE->ADC1_DATA_GOOD = FALSE;
				//PROCESS_VARS_HANDLE->ADC_CAPTURES_RUNNING = FALSE;
				ADC1_HANDLE->ADC1_IDLE = TRUE;

				error_catch();

				break;

		}

	}
	else if (ADC1_HANDLE->ADC1_DATA_GOOD == FALSE){			// TODO REEVALUATE THIS METHOD TO HANDLE BAD DATA

		error_catch();

	}
}

/***************************************************************************************************************************************/


void process_ADC_data(void){

	PROCESS_VARS_HANDLE->V_C1 = ADC1_Process_Data(ADC1_HANDLE->ADC_CH0_DATA);

	PROCESS_VARS_HANDLE->V_C2 = ADC1_Process_Data(ADC1_HANDLE->ADC_CH1_DATA);

	PROCESS_VARS_HANDLE->V_C3 = ADC1_Process_Data(ADC1_HANDLE->ADC_CH2_DATA);


}

/***************************************************************************************************************************************/

/* Error list / catch */

void error_catch(void){

	while(1);


}

/***************************************************************************************************************************************/

/*	Function to init the Process_Vars struct obj, assign handle the obj address if successful	*/

uint8_t Process_Vars_Obj_init(void *pMemory, Process_Vars_Obj_Alias obj){

	PROCESS_VARS_HANDLE = (Process_Vars_Obj_Alias*)calloc(1, sizeof(obj));

	if (PROCESS_VARS_HANDLE == NULL) { return 1; }

	PROCESS_VARS_HANDLE = (Process_Vars_Obj_Alias*)pMemory;

    return 0;

}

/***************************************************************************************************************************************/

/* Setup for one-shot */
/* Debounce is 200 counts max, high if > 100, low if < 100 */
/* Input is active low */

BOOL Debounce(uint8_t input, int *cnt, int *btn_lock){

	if (input == 0 && *cnt < 200) { (*cnt)++; } 		// increment counter
	else if (input == 1 && *cnt > 0) { (*cnt)--; }    	// decrement counter

	if (*btn_lock == 0){

		if (*cnt > 100) {

			*btn_lock = 1;			// lock btn until released
			return TRUE;				// send one-shot
		}
	}
	else if (*btn_lock == 1) {

		if (*cnt <= 100) {

			*btn_lock = 0;			// release lock
		}
	}

	return FALSE;
}

/***************************************************************************************************************************************/

void Millisec(float microSec){

	TIM3 -> ARR = (microSec / 1000000) / GetPeriod(SYS_CLK); //load TIM3 counter
	TIM3 -> CR1 |= 1; //start timer

	while(!ms_done_flag);

}










