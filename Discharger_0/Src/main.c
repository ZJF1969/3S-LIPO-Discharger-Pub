/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#include "ADC.h"
#include "IRQ.h"
#include "stm32f303re_sys_init.h"


#define GetPeriod(x) (1 / (float)x)


const uint32_t SYS_CLK = 72000000;

const float COARSE_SETPOINT = 3.8;
const float FINE_SETPOINT = 3.75;


/***************************************************************************************************************************************/

/*	Process_Vars obj and handle	*/

Process_Vars_Obj_Alias Process_Vars;			// Define struct obj of type Process_Vars_Obj_Alias
Process_Vars_Obj_Alias *Process_Vars_Handle;	// Define struct obj pointer to type Process_Vars_Obj_Alias

/***************************************************************************************************************************************/

/*	State Machine function prototypes  */

// Alpha states
void A0(void);  //state A0
void A1(void);  //state A1
void A2(void);  //state A2
void A3(void);

// Beta states
void B0(void);
void B1(void);
void B2(void);

/***************************************************************************************************************************************/

/*	State machine function pointers */

void (*State_ptr)(void);       // State machine pointer

/***************************************************************************************************************************************/


int PC13_cnt = 0;		// Debounce vars
int PC13_lock = 0;
BOOL PC13_pressed = FALSE;

int state = 0;			// Error catch

/***************************************************************************************************************************************/

int main(void){

	SysInit();
	GPIOConfig();
	TIMConfig();
	state = ADC_INIT();		// Init and cal ADC1, setup var obj
	DMA1_init();
	OPAMP_init();


	state = Process_Vars_Obj_init(&Process_Vars, Process_Vars);	// Init the Process_Vars obj
	if (state == 1) {}

	DMA_CH1_config();

	State_ptr = &B0;	// Set state machine entry to Idle state


	/*	Setup ADC1	*/

	state = ADC1_IRQ_Config();				// Setup ADC1 IRQs
	if (state == 1) { A2(); }

	state = EnableADC1();					// EN ADC1
	if (state == 1) { A2(); }

	state = GetVDDA();						// Sample the current VDDA (upper ref)
	if (state == 1) { A2(); }

	state = ADC1_Param_Setup();
	if (state == 1) { A2(); }



	while(1) {


		// WATCHDOG


		/*	Check for ON/OFF btn activity	*/

		PC13_pressed = Debounce( (((GPIOC->IDR) & GPIO_IDR_13) >> 13), &PC13_cnt, &PC13_lock); //poll blue btn, PC13, active low, service Debounce

		if (PC13_pressed == TRUE && Process_Vars_Handle->SYS_ON == FALSE){

			if(BattCheck() == TRUE){

				Process_Vars_Handle->SYS_ON = TRUE;
				State_ptr = &A0;

			}
			else{

				// Hold ERROR LED on for a while

			}

		}
		else if(PC13_pressed == TRUE && Process_Vars_Handle->SYS_ON == TRUE){

			Process_Vars_Handle->SYS_ON = FALSE;
			State_ptr = &B0;

			// Shut down state

			// TURN OFF LED

		}


		/*	Enter state machine	*/

		(*State_ptr)();

	}

}

/***************************************************************************************************************************************/

/* Startup state */

void A0(void){

	ADC1_IRQ_EN();							// EN ADC1 IRQs

	ADC1_HANDLE->ADC1_IDLE = TRUE;
	ADC1_HANDLE->ADC1_DATA_GOOD = TRUE;
	ADC1_HANDLE->ADC1_CURRENT_CAPTURE = 1;						// Reset to first ADC1 CH

	Process_Vars_Handle->ADC_CAPTURES_RUNNING = TRUE;			// Start ADC1 burst

	B0();		// Get Vcells
	B1();		// Process vals

	if (Process_Vars_Handle->V_C1 > 3.75 || Process_Vars_Handle->V_C2 > 3.75 || Process_Vars_Handle->V_C3 > 3.75){		// Check if discharge is applicable.

		if (Process_Vars_Handle->V_C1 < 3.6 || Process_Vars_Handle->V_C2 < 3.6 || Process_Vars_Handle->V_C3 < 3.6){		// Check for out of range / damaged cells

			//State_ptr = ERROR STATE

		}

		if (Process_Vars_Handle->V_C1 < 3.8 || Process_Vars_Handle->V_C2 < 3.8 || Process_Vars_Handle->V_C3 < 3.8){

			Process_Vars_Handle->Current_Setpoint = FINE_SETPOINT;		// Set to fine setpoint if close to done

		}
		else{

			Process_Vars_Handle->Current_Setpoint = COARSE_SETPOINT;	// Otherwise use coarse setpoint

		}


		// Turn on LED
		State_ptr = &A1;	// Start main logic

	}
	else{

		//State_ptr = DONE STATE // No discharge needed

	}
}

/***************************************************************************************************************************************/

/* Service State */

void A1(void){

	if (Process_Vars_Handle->DISCHARGE_ON == FALSE){

		Process_Vars_Handle->DISCHARGE_ON = TRUE;
		// START DISCHARGE

	}

	start_cell_check_timer();

	state_ptr = &B0;			// Go to capture state




}

/***************************************************************************************************************************************/

/* Running State */

void A2(void){















}

/***************************************************************************************************************************************/


/*	Error state  */

uint32_t diag_A2 = 0;

void A3(void){

	while(1);	// Get stuck for diag

}

/***************************************************************************************************************************************/

/*	Capture state  */

void B0(void){

	uint8_t result = 0;

	if (Process_Vars_Handle->ADC_CAPTURES_RUNNING == TRUE &&
			ADC1_HANDLE->ADC1_IDLE == TRUE &&
			ADC1_HANDLE->ADC1_DATA_GOOD == TRUE){				// If ADC1 burst running and ADC1 conv done and data ok so far

		ADC1_HANDLE->ADC1_IDLE = FALSE;												// Ready to start a conv

		switch (ADC1_HANDLE->ADC1_CURRENT_CAPTURE) {

			case 1:

				result = ADC1_Start_Conv(1, &ADC1_HANDLE->ADC1_CH1_DATA[0]);		// Start ADC1 CH1 conv, VC1
				if(result == 1){ /*set error*/ }

				break;


			case 2:

				result = ADC1_Start_Conv(2, &ADC1_HANDLE->ADC1_CH2_DATA[0]);		// Start ADC1 CH2 conv, VC2
				if(result == 1){ /*set error*/ }

				break;


			case 3:

				result = ADC1_Start_Conv(6, &ADC1_HANDLE->ADC1_CH6_DATA[0]);		// Start ADC1 CH3 conv, VC3
				if(result == 1){ /*set error*/ }

				break;


			case 4:

				/*
				result = ADC1_Start_Conv(4, &ADC1_HANDLE->ADC1_CH4_DATA[0]);		// Start ADC1 CH4 conv, NTC
				if(result == 1){ /*set error }
				*/

				ADC1_HANDLE->ADC1_IDLE = TRUE;										// Reverse to IDLE
				Process_Vars_Handle->ADC_CAPTURES_RUNNING = FALSE;					// ADC captures done, TODO move this to case 5 and add in ADC CH4
				State_ptr = &A1;

				//state = ADC1_Cycle_Start();
				//if (state == 1) { A2(); }

				break;


			default:

				/* Error Catch */

				ADC1_HANDLE->ADC1_DATA_GOOD = FALSE;
				Process_Vars_Handle->ADC_CAPTURES_RUNNING = FALSE;
				ADC1_HANDLE->ADC1_IDLE = TRUE;

				break;


		}

	}

}

/***************************************************************************************************************************************/


void B1(void){

	Process_Vars_Handle->V_C1 = ADC1_Process_Data(ADC1_HANDLE->ADC1_CH1_DATA);

	Process_Vars_Handle->V_C2 = ADC1_Process_Data(ADC1_HANDLE->ADC1_CH2_DATA);

	Process_Vars_Handle->V_C3 = ADC1_Process_Data(ADC1_HANDLE->ADC1_CH6_DATA);

	State_ptr = &A1;



}

/***************************************************************************************************************************************/

/*	Process Data State  */

void B2(void){

}

/***************************************************************************************************************************************/

/*	Function to init the Process_Vars struct obj, assign handle the obj address if successful	*/

uint8_t Process_Vars_Obj_init(void *pMemory, Process_Vars_Obj_Alias obj){

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)calloc(1, sizeof(obj));

	if (Process_Vars_Handle == NULL) { return 1; }

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)pMemory;

    return 0;

}

/***************************************************************************************************************************************/

/* Setup for one-shot */
/* Debounce is 200 counts max, high if > 100, low if < 100 */
/* Input is active low */

BOOL Debounce(uint8_t input, int *cnt, int *btn_lock){

	if (input == 0 && *cnt < 200) { (*cnt)++; } 		// increment counter
	else if (input == 1 && *cnt > 0) { (*cnt)--; }    	// decrement counter

	if (*btn_lock == 0){

		if (*cnt > 100) {

			*btn_lock = 1;			// lock btn until released
			return TRUE;				// send one-shot
		}
	}
	else if (*btn_lock == 1) {

		if (*cnt <= 100) {

			*btn_lock = 0;			// release lock
		}
	}

	return FALSE;
}

/***************************************************************************************************************************************/

void Millisec(float microSec){

	TIM3 -> ARR = (microSec / 1000000) / GetPeriod(SYS_CLK); //load TIM3 counter
	TIM3 -> CR1 |= 1; //start timer

	while(!ms_done_flag);

}










