/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#include "ADC.h"
#include "IRQ.h"
#include "stm32f303re_sys_init.h"


#define GetPeriod(x) (1 / (float)x)


const uint32_t SYS_clk;


/***************************************************************************************************************************************/

/*	Process_Vars obj and handle	*/

Process_Vars_Obj_Alias Process_Vars;			// Define struct obj of type Process_Vars_Obj_Alias
Process_Vars_Obj_Alias *Process_Vars_Handle;	// Define struct obj pointer to type Process_Vars_Obj_Alias

/***************************************************************************************************************************************/

/*	State Machine function prototypes  */

// Alpha states
void A0(void);  //state A0
void A1(void);  //state A1
void A2(void);  //state A2
void A3(void);

// Beta states
void B0(void);
void B1(void);
void B2(void);

/***************************************************************************************************************************************/

/*	State machine function pointers */

void (*State_ptr)(void);       // State machine pointer

/***************************************************************************************************************************************/


int PC13_cnt = 0;		// Debounce vars
int PC13_lock = 0;
BOOL PC13_pressed = 0;

int state = 0;			// Error catch

/***************************************************************************************************************************************/

int main(void){

	SysInit();
	GPIOConfig();
	TIMConfig();
	state = ADC_INIT();		// Init and cal ADC1, setup var obj
	DMA1_init();
	OPAMP_init();


	state = Process_Vars_Obj_init(&Process_Vars, Process_Vars);	// Init the Process_Vars obj
	if (state == 1) {}

	DMA_CH1_config();

	State_ptr = &B0;	// Set state machine entry to Idle state


	/*	Setup ADC1	*/

	state = ADC1_IRQ_Config();				// Setup ADC1 IRQs
	if (state == 1) { A2(); }

	state = EnableADC1();					// EN ADC1
	if (state == 1) { A2(); }

	state = GetVDDA();						// Sample the current VDDA (upper ref)
	if (state == 1) { A2(); }

	state = ADC1_Param_Setup();
	if (state == 1) { A2(); }

	ADC1_IRQ_EN();							// EN ADC1 IRQs

	Process_Vars_Handle->ADC1_Idle = 0x1;	// ADC is idle


	//state = ADC1_Cycle_Start();
	//if (state == 1) { A2(); }


	while(1) {


		// WATCHDOG


		/*	Check for ON/OFF btn activity	*/

		PC13_pressed = Debounce( (((GPIOC->IDR) & GPIO_IDR_13) >> 13), &PC13_cnt, &PC13_lock); //poll blue btn, PC13, active low, service Debounce

		if (PC13_pressed == TRUE && Process_Vars_Handle->SYS_ON == FALSE){

			Process_Vars_Handle->SYS_ON = TRUE;
			State_ptr = &A0;

		}
		else if(PC13_pressed == TRUE && Process_Vars_Handle->SYS_ON == TRUE){

			Process_Vars_Handle->SYS_ON = FALSE;
			State_ptr = &B0;

			// TURN OFF LED

		}


		/*	Enter state machine	*/

		(*State_ptr)();

	}

}

/***************************************************************************************************************************************/

/*	Startup state  			*/
/*	Turn LED, batt check	*/

void A0(void){

	// TURN ON LED


	//if(BATT_CHECK() == TRUE){

		State_ptr = &A1;

	//}

}

/***************************************************************************************************************************************/

/*	Running state  */

void A1(void){

	uint8_t result = 0;

	if (Process_Vars_Handle->ADC_Burst_Running == 0x1 && Process_Vars_Handle->ADC1_Idle == 0x1){		// If ADC1 burst running and ADC1 conv done

		Process_Vars_Handle->ADC1_Idle = 0x0;

		if (ADC1_HANDLE->ADC1_NEXT_CH == 0x1){

			result = ADC1_Start_Conv(ADC1_HANDLE->ADC1_NEXT_CH, &ADC1_HANDLE->ADC1_CH1_DATA[0]);		// Start ADC1 CH1 conv
			if(result == 1){ /*set error*/ }
			
			ADC1_HANDLE->ADC1_NEXT_CH = 0x2;					// Set next channel

		}
		else if (ADC1_HANDLE->ADC1_NEXT_CH == 0x2){
			
			result = ADC1_Start_Conv(ADC1_HANDLE->ADC1_NEXT_CH, &ADC1_HANDLE->ADC1_CH2_DATA[0]);		// Start ADC1 CH2 conv
			if(result == 1){ /*set error*/ }
			
			ADC1_HANDLE->ADC1_NEXT_CH = 0x4;					// Set next channel

		}
		else if (ADC1_HANDLE->ADC1_NEXT_CH == 0x4){
			
			result = ADC1_Start_Conv(ADC1_HANDLE->ADC1_NEXT_CH, &ADC1_HANDLE->ADC1_CH4_DATA[0]);		// Start ADC1 CH4 conv
			if(result == 1){ /*set error*/ }

			ADC1_HANDLE->ADC1_NEXT_CH = 0x1;					// Reset next channel
			Process_Vars_Handle->ADC_Burst_Running = 0x0;		// ADC1 burst done

		}

	}



	/*

	if ((Process_Vars_Handle->ADC1_Idle & Process_Vars_Handle->ADC1_CH1_Data_Good) == 0x1) {

		ADC1_Process_Data();
		State_ptr = &B2;

	}
*/
}

/***************************************************************************************************************************************/

/*	Burst finished, process data, move to reset state	*/

void A3(void){

	ADC1_Process_Data();

	State_ptr = &B2;

}

/***************************************************************************************************************************************/


/*	Error state  */

uint32_t diag_A2 = 0;

void A2(void){

	while(1);	// Get stuck for diag

}

/***************************************************************************************************************************************/

/*	Idle state  */
/*	Do nothing	*/

void B0(void){


}

/***************************************************************************************************************************************/

/*	ADC1 wait and burst check state  */
/*
void B1(void){

	if (ADC1_HANDLE->ADC1_EOC == 1){

		if (ADC1_HANDLE->ADC1_CH1_N == ADC1_N_BURST_CONST) {		// Wait for conv burst done

			ADC1_HANDLE->ADC1_EOC = 0;	// Reset EOC flag for main loop
			State_ptr = &A3;	// Move to done state

			return;

		}

		ADC1_HANDLE->ADC1_EOC = 0;	// Reset EOC flag for main loop
		State_ptr = &A1;				// Move to running state

	}

}
*/
/***************************************************************************************************************************************/

float new_d = 30;

void B2(void){

	new_d = (ADC1_HANDLE->ADC1_AIN * 0.25) + 0.175;

	//UpdatePWM(new_d);

	State_ptr = &A1;


}

/***************************************************************************************************************************************/

/*	Function to init the Process_Vars struct obj, assign handle the obj address if successful	*/

uint8_t Process_Vars_Obj_init(void *pMemory, Process_Vars_Obj_Alias obj){

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)calloc(1, sizeof(obj));

	if (Process_Vars_Handle == NULL) { return 1; }

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)pMemory;

    return 0;

}

/***************************************************************************************************************************************/

/* Setup for one-shot */
/* Debounce is 200 counts max, high if > 100, low if < 100 */

BOOL Debounce(uint16_t input, int *cnt, int *btn_lock){

	if (~input == 1 && *cnt < 200) { (*cnt)++; } 		// increment counter
	else if (~input == 0 && *cnt > 0) { (*cnt)--; }    	// decrement counter

	if (*btn_lock == 0){

		if (*cnt > 100) {

			*btn_lock = 1;			// lock btn until released
			return TRUE;				// send one-shot
		}
	}
	else if (*btn_lock == 1) {

		if (*cnt <= 100) {

			*btn_lock = 0;			// release lock
		}
	}

	return FALSE;
}

/***************************************************************************************************************************************/

void Millisec(float microSec){

	TIM3 -> ARR = (microSec / 1000000) / GetPeriod(SYS_clk); //load TIM3 counter
	TIM3 -> CR1 |= 1; //start timer

	while(!ms_done_flag);

}










