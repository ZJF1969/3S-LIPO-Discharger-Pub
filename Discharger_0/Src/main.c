/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"


#define GetPeriod(x) (1 / (float)x)

/***************************************************************************************************************************************/

/*	Process_Vars obj and handle	*/

Process_Vars_Obj_Alias Process_Vars;			// Define struct obj of type Process_Vars_Obj_Alias
Process_Vars_Obj_Alias *Process_Vars_Handle;	// Define struct obj pointer to type Process_Vars_Obj_Alias

/***************************************************************************************************************************************/

/*	State Machine function prototypes  */

// Alpha states
void A0(void);  //state A0
void A1(void);  //state A1
void A2(void);  //state A2
void A3(void);

// Beta states
void B0(void);
void B1(void);
void B2(void);

/***************************************************************************************************************************************/

/*	State machine function pointers */

void (*State_ptr)(void);       // State machine pointer

/***************************************************************************************************************************************/


int PC13_cnt = 0;		// Debounce vars
int PC13_lock = 0;
int PC13_pressed = 0;

int state = 0;

/***************************************************************************************************************************************/

int main(void){

	SysInit();
	GPIOConfig();
	TIMConfig();
	state = ADC_INIT();		// Init and cal ADC1, setup var obj
	DMA1_init();
	OPAMP_init();


	state = Process_Vars_Obj_init(&Process_Vars, Process_Vars);	// Init the Process_Vars obj
	if (state == 1) {}

	DMA_CH1_config();

	State_ptr = &B0;	// Set state machine entry


	/*	Setup ADC1	*/

	state = ADC1_IRQ_Config();				// Setup ADC1 IRQs
	if (state == 1) { A2(); }

	state = EnableADC1();					// EN ADC1
	if (state == 1) { A2(); }

	state = GetVDDA();						// Sample the current VDDA (upper ref)
	if (state == 1) { A2(); }

	state = ADC1_Param_Setup();
	if (state == 1) { A2(); }


	ADC1_IRQ_EN();							// EN ADC1 IRQs

	Process_Vars_Handle->ADC1_Idle = 0x1;	// ADC1 idle


	state = ADC1_Cycle_Start();
	if (state == 1) { A2(); }


	while(1) {




		(*State_ptr)();

	}

}

/***************************************************************************************************************************************/

/*	Idle state  */

void A0(void){

	//PC13_pressed = Debounce( (((GPIOC -> IDR) & GPIO_IDR_13) >> 13), &PC13_cnt, &PC13_lock); //poll blue btn, PC13, active low, service Debounce

	//if (PC13_pressed == 1) {

		//State_ptr = &A1;
	//}

	if (Process_Vars_Handle->ADC1_Idle == 0x0){

		State_ptr = &A1;
	}





}

/***************************************************************************************************************************************/

/*	Running state  */

void A1(void){

	if ((Process_Vars_Handle->ADC1_Idle & Process_Vars_Handle->ADC1_CH1_Data_Good) == 0x1) {

		ADC1_Process_Data();
		State_ptr = &B2;

	}

}

/***************************************************************************************************************************************/

/*	Burst finished, process data, move to reset state	*/

void A3(void){

	ADC1_Process_Data();

	State_ptr = &B2;

}

/***************************************************************************************************************************************/


/*	Error state  */

uint32_t diag_A2 = 0;

void A2(void){

	while(1);	// Get stuck for diag

}

/***************************************************************************************************************************************/



void B0(void){



}

/***************************************************************************************************************************************/

/*	ADC1 wait and burst check state  */
/*
void B1(void){

	if (ADC1_HANDLE->ADC1_EOC == 1){

		if (ADC1_HANDLE->ADC1_CH1_N == ADC1_N_BURST_CONST) {		// Wait for conv burst done

			ADC1_HANDLE->ADC1_EOC = 0;	// Reset EOC flag for main loop
			State_ptr = &A3;	// Move to done state

			return;

		}

		ADC1_HANDLE->ADC1_EOC = 0;	// Reset EOC flag for main loop
		State_ptr = &A1;				// Move to running state

	}

}
*/
/***************************************************************************************************************************************/

float new_d = 30;

void B2(void){

	new_d = (ADC1_HANDLE->ADC1_AIN * 0.25) + 0.175;

	UpdatePWM(new_d);

	State_ptr = &A1;


}

/***************************************************************************************************************************************/

/*	Function to init the Process_Vars struct obj, assign handle the obj address if successful	*/

uint8_t Process_Vars_Obj_init(void *pMemory, Process_Vars_Obj_Alias obj){

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)calloc(1, sizeof(obj));

	if (Process_Vars_Handle == NULL) { return 1; }

	Process_Vars_Handle = (Process_Vars_Obj_Alias*)pMemory;

    return 0;

}

/***************************************************************************************************************************************/

int Debounce(uint16_t input, int *cnt, int *btn_lock){

	/* Setup for one-shot */
	/* Debounce is 200 counts max, high if > 100, low if < 100 */

	if (input == 0 && *cnt < 0x7D0) { (*cnt)++; } // increment counter
	else if (input == 1 && *cnt > 0) { (*cnt)--; }    // decrement counter

	if (*btn_lock == 0){

		if (*cnt > 0x64) {

			*btn_lock = 1;	// lock btn until released
			return 1;		// send one-shot
		}
	}
	else if (*btn_lock == 1) {

		if (*cnt <= 0x64) {

			*btn_lock = 0;
		}
	}

	return 0;
}

/***************************************************************************************************************************************/

void Millisec(float microSec){

	TIM3 -> ARR = (microSec / 1000000) / GetPeriod(SYS_clk); //load TIM3 counter
	TIM3 -> CR1 |= 1; //start timer

	while(!ms_done_flag);

}










